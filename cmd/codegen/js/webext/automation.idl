// Copyright 2014 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The <code>chrome.automation</code> API allows developers to access the
// automation (accessibility) tree for the browser. The tree resembles the DOM
// tree, but only exposes the <em>semantic</em> structure of a page. It can be
// used to programmatically interact with a page by examining names, roles, and
// states, listening for events, and performing actions on nodes.

// Keep the following enums in sync with 'ui/accessibility/ax_enums.mojom'.
// They are kept here purely for extension docs generation.

// Possible events fired on an $(ref:automation.AutomationNode).
[Namespace=(chrome, automation)]
enum EventType {
  "accessKeyChanged",
  "activeDescendantChanged",
  "alert",
  // TODO(crbug.com/1464633) Fully remove ariaAttributeChangedDeprecated
  // starting in 122, because although it was removed in 118, it is still
  // present in earlier versions of LaCros.
  "ariaAttributeChangedDeprecated",
  "ariaCurrentChanged",
  "atomicChanged",
  "autoCompleteChanged",
  "autocorrectionOccured",
  "autofillAvailabilityChanged",
  "blur",
  "busyChanged",
  "caretBoundsChanged",
  "checkedStateChanged",
  "checkedStateDescriptionChanged",
  "childrenChanged",
  "classNameChanged",
  "clicked",
  "collapsed",
  "controlsChanged",
  "detailsChanged",
  "describedByChanged",
  "descriptionChanged",
  "documentSelectionChanged",
  "documentTitleChanged",
  "dropeffectChanged",
  "editableTextChanged",
  "enabledChanged",
  "endOfTest",
  "expanded",
  "expandedChanged",
  "flowFromChanged",
  "flowToChanged",
  "focus",
  "focusAfterMenuClose",
  "focusChanged",
  "focusContext",
  "grabbedChanged",
  "haspopupChanged",
  "hide",
  "hierarchicalLevelChanged",
  "hitTestResult",
  "hover",
  "ignoredChanged",
  "imageAnnotationChanged",
  "imageFrameUpdated",
  "invalidStatusChanged",
  "keyShortcutsChanged",
  "labeledByChanged",
  "languageChanged",
  "layoutComplete",
  "layoutInvalidated",  // fired when aria-busy goes false
  "liveRegionChanged",
  "liveRegionCreated",
  "liveRegionNodeChanged",  // fired on a node within a live region.
  "liveRelevantChanged",
  "liveStatusChanged",
  "loadComplete",
  "loadStart",
  "locationChanged",
  "mediaStartedPlaying",
  "mediaStoppedPlaying",
  "menuEnd",
  "menuItemSelected",
  "menuListValueChanged",
  "menuPopupEnd",
  "menuPopupStart",
  "menuStart",
  "mouseCanceled",
  "mouseDragged",
  "mouseMoved",
  "mousePressed",
  "mouseReleased",
  "multilineStateChanged",
  "multiselectableStateChanged",
  "nameChanged",
  "objectAttributeChanged",
  "orientationChanged",
  "otherAttributeChanged",
  "parentChanged",
  "placeholderChanged",
  "portalActivated",
  "positionInSetChanged",
  "rangeValueChanged",
  "rangeValueMaxChanged",
  "rangeValueMinChanged",
  "rangeValueStepChanged",
  "readonlyChanged",
  "relatedNodeChanged",
  "requiredStateChanged",
  "roleChanged",
  "rowCollapsed",
  "rowCountChanged",
  "rowExpanded",
  "scrollHorizontalPositionChanged",
  "scrollPositionChanged",
  "scrollVerticalPositionChanged",
  "scrolledToAnchor",
  "selectedChanged",
  "selectedChildrenChanged",
  "selectedValueChanged",
  "selection",
  "selectionAdd",
  "selectionRemove",
  "setSizeChanged",
  "show",
  "sortChanged",
  "stateChanged",
  "subtreeCreated",
  "textAttributeChanged",
  "textSelectionChanged",
  "textChanged",
  "tooltipClosed",
  "tooltipOpened",
  "treeChanged",
  "valueInTextFieldChanged",
  "valueChanged",  // Deprecated.
  "windowActivated",
  "windowDeactivated",
  "windowVisibilityChanged",
};

// Describes the purpose of an $(ref:automation.AutomationNode).
[Namespace=(chrome, automation)]
enum RoleType {
  "abbr",
  "alert",
  "alertDialog",
  "application",
  "article",
  "audio",
  "banner",
  "blockquote",
  "button",
  "canvas",
  "caption",
  "caret",
  "cell",
  "checkBox",
  "client",
  "code",
  "colorWell",
  "column",
  "columnHeader",
  "comboBoxGrouping",
  "comboBoxMenuButton",
  "comboBoxSelect",
  "comment",
  "complementary",
  "contentDeletion",
  "contentInsertion",
  "contentInfo",
  "date",
  "dateTime",
  "definition",
  "descriptionList",
  "descriptionListDetail",
  "descriptionListTerm",
  "desktop",
  "details",
  "dialog",
  "directory",
  "disclosureTriangle",
  // --------------------------------------------------------------
  // DPub Roles:
  // https://www.w3.org/TR/dpub-aam-1.0/#mapping_role_table
  "docAbstract",
  "docAcknowledgments",
  "docAfterword",
  "docAppendix",
  "docBackLink",
  "docBiblioEntry",
  "docBibliography",
  "docBiblioRef",
  "docChapter",
  "docColophon",
  "docConclusion",
  "docCover",
  "docCredit",
  "docCredits",
  "docDedication",
  "docEndnote",
  "docEndnotes",
  "docEpigraph",
  "docEpilogue",
  "docErrata",
  "docExample",
  "docFootnote",
  "docForeword",
  "docGlossary",
  "docGlossRef",
  "docIndex",
  "docIntroduction",
  "docNoteRef",
  "docNotice",
  "docPageBreak",
  "docPageFooter",
  "docPageHeader",
  "docPageList",
  "docPart",
  "docPreface",
  "docPrologue",
  "docPullquote",
  "docQna",
  "docSubtitle",
  "docTip",
  "docToc",
  // End DPub roles.
  // --------------------------------------------------------------
  "document",
  "embeddedObject",
  "emphasis",
  "feed",
  "figcaption",
  "figure",
  "footer",
  "footerAsNonLandmark",
  "form",
  "genericContainer",
  // --------------------------------------------------------------
  // ARIA Graphics module roles:
  // https://rawgit.com/w3c/graphics-aam/master/#mapping_role_table
  "graphicsDocument",
  "graphicsObject",
  "graphicsSymbol",
  // End ARIA Graphics module roles.
  // --------------------------------------------------------------
  "grid",
  "group",
  "header",
  "headerAsNonLandmark",
  "heading",
  "iframe",
  "iframePresentational",
  "image",
  "imeCandidate",
  "inlineTextBox",
  "inputTime",
  "keyboard",
  "labelText",
  "layoutTable",
  "layoutTableCell",
  "layoutTableRow",
  "legend",
  "lineBreak",
  "link",
  "list",
  "listBox",
  "listBoxOption",
  "listGrid",  // Native
  "listItem",
  "listMarker",
  "log",
  "main",
  "mark",
  "marquee",
  "math",
  "mathMLFraction",
  "mathMLIdentifier",
  "mathMLMath",
  "mathMLMultiscripts",
  "mathMLNoneScript",
  "mathMLNumber",
  "mathMLOperator",
  "mathMLOver",
  "mathMLPrescriptDelimiter",
  "mathMLRoot",
  "mathMLRow",
  "mathMLSquareRoot",
  "mathMLStringLiteral",
  "mathMLSub",
  "mathMLSubSup",
  "mathMLSup",
  "mathMLTable",
  "mathMLTableCell",
  "mathMLTableRow",
  "mathMLText",
  "mathMLUnder",
  "mathMLUnderOver",
  "menu",
  "menuBar",
  "menuItem",
  "menuItemCheckBox",
  "menuItemRadio",
  "menuListOption",
  "menuListPopup",
  "meter",
  "navigation",
  "note",
  "pane",
  "paragraph",
  "pdfActionableHighlight",
  "pdfRoot",
  "pluginObject",
  "popUpButton",
  "portal",
  "preDeprecated",
  "progressIndicator",
  "radioButton",
  "radioGroup",
  "region",
  "rootWebArea",
  "row",
  "rowGroup",
  "rowHeader",
  "ruby",
  "rubyAnnotation",
  "scrollBar",
  "scrollView",
  "search",
  "searchBox",
  "section",
  "slider",
  "spinButton",
  "splitter",
  "staticText",
  "status",
  "strong",
  "subscript",
  "suggestion",
  "superscript",
  "svgRoot",
  "switch",
  "tab",
  "tabList",
  "tabPanel",
  "table",
  "tableHeaderContainer",
  "term",
  "textField",
  "textFieldWithComboBox",
  "time",
  "timer",
  "titleBar",
  "toggleButton",
  "toolbar",
  "tooltip",
  "tree",
  "treeGrid",
  "treeItem",
  "unknown",
  "video",
  "webView",
  "window",
};

// Describes characteristics of an $(ref:automation.AutomationNode).
[Namespace=(chrome, automation)]
enum StateType {
  "autofillAvailable",
  "collapsed",
  "default",
  "editable",
  "expanded",
  "focusable",
  "focused",
  "horizontal",
  "hovered",
  "ignored",
  "invisible",
  "linked",
  "multiline",
  "multiselectable",
  "offscreen",
  "protected",
  "required",
  "richlyEditable",
  "vertical",
  "visited",
};

// All possible actions that can be performed on automation nodes.
[Namespace=(chrome, automation)]
enum ActionType {
  "annotatePageImages",
  "blur",
  "clearAccessibilityFocus",
  "collapse",
  "customAction",
  "decrement",
  "doDefault",
  "expand",
  "focus",
  "getImageData",
  "getTextLocation",
  "hideTooltip",
  "hitTest",
  "increment",
  "internalInvalidateTree",
  "loadInlineTextBoxes",
  "longClick",
  "replaceSelectedText",
  "resumeMedia",
  "scrollBackward",
  "scrollDown",
  "scrollForward",
  "scrollLeft",
  "scrollRight",
  "scrollUp",
  "scrollToMakeVisible",
  "scrollToPoint",
  "scrollToPositionAtRowColumn",
  "setAccessibilityFocus",
  "setScrollOffset",
  "setSelection",
  "setSequentialFocusNavigationStartingPoint",
  "setValue",
  "showContextMenu",
  "signalEndOfTest",
  "showTooltip",
  "startDuckingMedia",
  "stopDuckingMedia",
  "suspendMedia",
};

// Possible changes to the automation tree. For any given atomic change
// to the tree, each node that's added, removed, or changed, will appear
// in exactly one TreeChange, with one of these types.
//
// nodeCreated means that this node was added to the tree and its parent is
// new as well, so it's just one node in a new subtree that was added.
[Namespace=(chrome, automation)]
enum TreeChangeType {
  /**
   * This node was added to the tree and its parent is new as well,
   * so it's just one node in a new subtree that was added.
   */
  "nodeCreated",

  /**
   * This node was added to the tree but its parent was already in the
   * tree, so it's possibly the root of a new subtree - it does not mean
   * that it necessarily has children.
   */
  "subtreeCreated",

  /**
   * This node changed.
   */
  "nodeChanged",

  /**
   * This node's text (name) changed.
   */
  "textChanged",

  /**
   * This node was removed.
   */
  "nodeRemoved",
  /**
   * This subtree has finished an update.
   */
  "subtreeUpdateEnd",
};

// Where the node's name is from.
[Namespace=(chrome, automation)]
enum NameFromType {
  "attribute",
  "attributeExplicitlyEmpty",
  "caption",
  "contents",
  "placeholder",
  "popoverAttribute",
  "relatedElement",
  "title",
  "value",
};

[Namespace=(chrome, automation)]
enum DescriptionFromType {
  "ariaDescription",
  "attributeExplicitlyEmpty",
  "buttonLabel",
  "popoverAttribute",
  "relatedElement",
  "rubyAnnotation",
  "summary",
  "svgDescElement",
  "tableCaption",
  "title",
};

// The input restriction for a object -- even non-controls can be disabled.
[Namespace=(chrome, automation)]
enum Restriction {
  "disabled",
  "readOnly",
};

// Availability and types for an interactive popup element.
[Namespace=(chrome, automation)]
enum HasPopup {
  "false",
  "true",
  "menu",
  "listbox",
  "tree",
  "grid",
  "dialog",
};

// Indicates the ARIA-current state.
[Namespace=(chrome, automation)]
enum AriaCurrentState {
  "false",
  "true",
  "page",
  "step",
  "location",
  "date",
  "time",
};

// Lists the values that `invalidState` can take on.
[Namespace=(chrome, automation)]
enum InvalidState {
  "false",
  "true",
};

// Describes possible actions when performing a do default action.
[Namespace=(chrome, automation)]
enum DefaultActionVerb {
  "activate",
  "check",
  "click",
  "clickAncestor",
  "jump",
  "open",
  "press",
  "select",
  "uncheck",
};

// Types of markers on text. See <code>AutomationNode.markerTypes</code>.
[Namespace=(chrome, automation)]
enum MarkerType {
  "spelling",
  "grammar",
  "textMatch",
  "activeSuggestion",
  "suggestion",
  "highlight",
};

// The following three enums are associated with an $(ref:automation.AutomationIntent).

// A command associated with an $(ref:automation.AutomationIntent).
[Namespace=(chrome, automation)]
enum IntentCommandType {
  "clearSelection",
  "delete",
  "dictate",
  "extendSelection",
  "format",
  "history",
  "insert",
  "marker",
  "moveSelection",
  "setSelection",
};

// The type of an input event associated with an $(ref:automation.AutomationIntent). It describes an edit
// command, e.g. IntentCommandType.insert, in more detail.
[Namespace=(chrome, automation)]
enum IntentInputEventType {
  // Insertion.
  "insertText",
  "insertLineBreak",
  "insertParagraph",
  "insertOrderedList",
  "insertUnorderedList",
  "insertHorizontalRule",
  "insertFromPaste",
  "insertFromDrop",
  "insertFromYank",
  "insertTranspose",
  "insertReplacementText",
  "insertCompositionText",
  // Deletion.
  "deleteWordBackward",
  "deleteWordForward",
  "deleteSoftLineBackward",
  "deleteSoftLineForward",
  "deleteHardLineBackward",
  "deleteHardLineForward",
  "deleteContentBackward",
  "deleteContentForward",
  "deleteByCut",
  "deleteByDrag",
  // History.
  "historyUndo",
  "historyRedo",
  // Formatting.
  "formatBold",
  "formatItalic",
  "formatUnderline",
  "formatStrikeThrough",
  "formatSuperscript",
  "formatSubscript",
  "formatJustifyCenter",
  "formatJustifyFull",
  "formatJustifyRight",
  "formatJustifyLeft",
  "formatIndent",
  "formatOutdent",
  "formatRemove",
  "formatSetBlockTextDirection",
};

// A text boundary associated with an $(ref:automation.AutomationIntent).
[Namespace=(chrome, automation)]
enum IntentTextBoundaryType {
  "character",
  "formatEnd",
  "formatStart",
  "formatStartOrEnd",
  "lineEnd",
  "lineStart",
  "lineStartOrEnd",
  "object",
  "pageEnd",
  "pageStart",
  "pageStartOrEnd",
  "paragraphEnd",
  "paragraphStart",
  "paragraphStartSkippingEmptyParagraphs",
  "paragraphStartOrEnd",
  "sentenceEnd",
  "sentenceStart",
  "sentenceStartOrEnd",
  "webPage",
  "wordEnd",
  "wordStart",
  "wordStartOrEnd",
};

// A move direction associated with an $(ref:automation.AutomationIntent).
[Namespace=(chrome, automation)]
enum IntentMoveDirectionType {
  "backward",
  "forward",
};

// A sort applied to a table row or column header.
[Namespace=(chrome, automation)]
enum SortDirectionType {
  "unsorted",
  "ascending",
  "descending",
  "other",
};

// A type of AutomationPosition.
[Namespace=(chrome, automation)]
enum PositionType {
  "null",
  "text",
  "tree",
};

[Namespace=(chrome, automation)]
dictionary Rect {
  long left;
  long top;
  long width;
  long height;
};

// Arguments for the find() and findAll() methods.
[Namespace=(chrome, automation), nocompile, noinline_doc]
dictionary FindParams {
  RoleType? role;

  // A map of $(ref:automation.StateType) to boolean, indicating for each
  // state whether it should be set or not. For example:
  // <code>{ StateType.disabled: false }</code> would only match if
  // <code>StateType.disabled</code> was <em>not</em> present in the node's
  // <code>state</code> object.
  object? state;

  // A map of attribute name to expected value, for example
  // <code>{ name: 'Root directory', checkbox_mixed: true }</code>.
  // String attribute values may be specified as a regex, for example
  // <code>{ name: /stralia$/</code> }</code>.
  // Unless specifying a regex, the expected value must be an exact match
  // in type and value for the actual value. Thus, the type of expected value
  // must be one of:
  // <ul>
  // <li>string</li>
  // <li>integer</li>
  // <li>float</li>
  // <li>boolean</li>
  // </ul>
  object? attributes;
};

// Arguments for the setDocumentSelection() function.
[Namespace=(chrome, automation), nocompile, noinline_doc]
dictionary SetDocumentSelectionParams {
  // The node where the selection begins.
  [instanceOf="AutomationNode"] object anchorObject;

  // The offset in the anchor node where the selection begins.
  long anchorOffset;

  // The node where the selection ends.
  [instanceOf="AutomationNode"] object focusObject;

  // The offset within the focus node where the selection ends.
  long focusOffset;
};

[Namespace=(chrome, automation), nocompile, noinline_doc]
dictionary AutomationIntent {
  // A command associated with this AutomationIntent.
  IntentCommandType command;

  // A text boundary associated with this AutomationIntent.
  IntentTextBoundaryType textBoundary;

  // A move direction associated with this AutomationIntent.
  IntentMoveDirectionType moveDirection;
};

// An event in the Automation tree.
[Namespace=(chrome, automation), nocompile, noinline_doc]
interface AutomationEvent {
  // The $(ref:automation.AutomationNode) to which the event was targeted.
  attribute AutomationNode target;

  // The type of the event.
  attribute EventType type;

  // The source of this event.
  attribute DOMString eventFrom;

  // Any mouse coordinates associated with this event.
  attribute long mouseX;
  attribute long mouseY;

  // A list of $(ref:automation.AutomationIntent)s associated with this event.
  attribute sequence<AutomationIntent> intents;

  // Stops this event from further processing except for any remaining
  // listeners on $(ref:automation.AutomationEvent.target).
  void stopPropagation();
};

// A listener for events on an <code>AutomationNode</code>.
[Namespace=(chrome, automation)]
callback AutomationListener = void(AutomationEvent event);

// A change to the Automation tree.
[Namespace=(chrome, automation), nocompile, noinline_doc]
dictionary TreeChange {
  // The $(ref:automation.AutomationNode) that changed.
  AutomationNode target;

  // The type of change.
  TreeChangeType type;
};

// Possible tree changes to listen to using addTreeChangeObserver.
// Note that listening to all tree changes can be expensive.
[Namespace=(chrome, automation)]
enum TreeChangeObserverFilter {
  "noTreeChanges",
  "liveRegionTreeChanges",
  "textMarkerChanges",
  "allTreeChanges",
};

// A listener for changes on the <code>AutomationNode</code> tree.
[Namespace=(chrome, automation)]
callback TreeChangeObserver = void(TreeChange treeChange);

// Callback called for actions with a response.
[Namespace=(chrome, automation)]
callback PerformActionCallback = void(boolean result);
[Namespace=(chrome, automation)]
callback PerformActionCallbackWithNode = void(AutomationNode node);
[Namespace=(chrome, automation)]
callback BoundsForRangeCallback = void(Rect bounds);

    [Namespace=(chrome, automation), nocompile, noinline_doc]
dictionary CustomAction {
  long id;
  DOMString description;
};

  // A marker associated with an AutomationNode.
[Namespace=(chrome, automation), nocompile, noinline_doc]
dictionary Marker {
  // The start offset within the text of the associated node.
  long startOffset;

  // The end offset within the text of the associated node.
  long endOffset;

  // A mapping of MarkerType to true or undefined indicating the marker types
  // for this marker.
  object flags;
};

// A position in the automation tree.
// See ui/accessibility/ax_position.h for documentation. All members need to
// be kept in sync with
// extensions/renderer/api/automation/automation_position.h.
// Some members there are kept private and not represented here.
[Namespace=(chrome, automation), nocompile, noinline_doc]
interface AutomationPosition {

  attribute AutomationNode? node;
  attribute long childIndex;
  attribute long textOffset;
  attribute DOMString affinity;

  boolean isNullPosition();
  boolean isTreePosition();
  boolean isTextPosition();
  boolean isLeafTextPosition();
  boolean atStartOfAnchor();
  boolean atEndOfAnchor();
  boolean atStartOfWord();
  boolean atEndOfWord();
  boolean atStartOfLine();
  boolean atEndOfLine();
  boolean atStartOfParagraph();
  boolean atEndOfParagraph();
  boolean atStartOfPage();
  boolean atEndOfPage();
  boolean atStartOfFormat();
  boolean atEndOfFormat();
  boolean atStartOfDocument();
  boolean atEndOfDocument();
  void asTreePosition();
  void asTextPosition();
  void asLeafTextPosition();
  void moveToPositionAtStartOfAnchor();
  void moveToPositionAtEndOfAnchor();
  void moveToPositionAtStartOfDocument();
  void moveToPositionAtEndOfDocument();
  void moveToParentPosition();
  void moveToNextLeafTreePosition();
  void moveToPreviousLeafTreePosition();
  void moveToNextLeafTextPosition();
  void moveToPreviousLeafTextPosition();
  void moveToNextCharacterPosition();
  void moveToPreviousCharacterPosition();
  void moveToNextWordStartPosition();
  void moveToPreviousWordStartPosition();
  void moveToNextWordEndPosition();
  void moveToPreviousWordEndPosition();
  void moveToNextLineStartPosition();
  void moveToPreviousLineStartPosition();
  void moveToNextLineEndPosition();
  void moveToPreviousLineEndPosition();
  void moveToNextFormatStartPosition();
  void moveToPreviousFormatStartPosition();
  void moveToNextFormatEndPosition();
  void moveToPreviousFormatEndPosition();
  void moveToNextParagraphStartPosition();
  void moveToPreviousParagraphStartPosition();
  void moveToNextParagraphEndPosition();
  void moveToPreviousParagraphEndPosition();
  void moveToNextPageStartPosition();
  void moveToPreviousPageStartPosition();
  void moveToNextPageEndPosition();
  void moveToPreviousPageEndPosition();
  void moveToNextAnchorPosition();
  void moveToPreviousAnchorPosition();
  long maxTextOffset();
  boolean isInLineBreak();
  boolean isInTextObject();
  boolean isInWhiteSpace();
  boolean isValid();
  DOMString getText();
};

// A single node in an Automation tree.
[Namespace=(chrome, automation), nocompile, noinline_doc]
interface AutomationNode {
  // The root node of the tree containing this AutomationNode.
  attribute AutomationNode? root;

  // Whether this AutomationNode is a root node.
  attribute boolean isRootNode;

  // The role of this node.
  attribute RoleType? role;

  // The $(ref:automation.StateType)s describing this node.
  // <jsexterns>@type {Object<chrome.automation.StateType, boolean>}
  // </jsexterns>
  attribute object? state;

  // The rendered location (as a bounding box) of this node in global
  // screen coordinates.
  attribute Rect location;

  // Determines the location of the text within the node specified by
  // |startIndex| and |endIndex|, inclusively. Invokes |callback| with the
  // bounding rectangle, in screen coordinates. |callback| can be invoked
  // either synchronously or asynchronously. The bounds are clipped to
  // ancestors.
  void boundsForRange(long startIndex, long endIndex,
      BoundsForRangeCallback callback);

  // Determines the location of the text within the node specified by
  // |startIndex| and |endIndex|, inclusively. Invokes |callback| with the
  // bounding rectangle, in screen coordinates. |callback| can be invoked
  // either synchronously or asynchronously. The bounds are not clipped to
  // ancestors.
  void unclippedBoundsForRange(long startIndex, long endIndex,
      BoundsForRangeCallback callback);

  // The location (as a bounding box) of this node in global screen
  // coordinates without applying any clipping from ancestors.
  attribute Rect? unclippedLocation;

  // The purpose of the node, other than the role, if any.
  attribute DOMString? description;

  // Description of the state of the checkbox.
  // Used only when the node is checkable.
  attribute DOMString? checkedStateDescription;

  // The placeholder for this text field, if any.
  attribute DOMString? placeholder;

  // The role description for this node.
  attribute DOMString? roleDescription;

  // The accessible name for this node, via the
  // <a href="http://www.w3.org/TR/wai-aria/#namecalculation">
  // Accessible Name Calculation</a> process.
  attribute DOMString? name;

  // Explains what will happen when the doDefault action is performed.
  attribute DOMString? doDefaultLabel;

  // Explains what will happen when the long click action is performed.
  attribute DOMString? longClickLabel;

  // The tooltip of the node, if any.
  attribute DOMString? tooltip;

  // The source of the name.
  attribute NameFromType? nameFrom;

  // The image annotation for image nodes, which may be a human-readable
  // string that is the contextualized annotation or a status string related
  // to annotations.
  attribute DOMString? imageAnnotation;

  // The value for this node: for example the <code>value</code> attribute of
  // an <code>&lt;input&gt; element.
  attribute DOMString? value;

  // The HTML tag for this element, if this node is an HTML element.
  attribute DOMString? htmlTag;

  // The level of a heading or tree item.
  attribute long? hierarchicalLevel;

  // The current caret bounds in screen coordinates.
  attribute Rect? caretBounds;

  // The start and end index of each word in an inline text box.
  attribute sequence<long>? wordStarts;
  attribute sequence<long>? wordEnds;

  // The start indexes of each sentence within the node's name.
  attribute sequence<long>? sentenceStarts;

  // The end indexes of each sentence within the node's name. For most nodes,
  // the size of sentenceStarts array should be equal to the size of
  // sentenceEnds array. Two exceptions are (1) node at the begining of a
  // paragraph but the end of the node's sentences is in its following node.
  // Such a node has one more start index. (2) Node at the end of a paragraph
  // but the start of the node's sentences is in its previous node. Such a
  // node has one more end index. For example, <p><b>Hello</b> world.</p> has
  // two nodes. The first one has one start index (i.e., 0) but no end index.
  // The second node has one end index (i.e., 7) but no start index.
  attribute sequence<long>? sentenceEnds;

  // The start index of each word within the node's name. This is different
  // from wordStarts because it is not restricted to inline text boxes and can
  // be used for any type of element.
  attribute sequence<long>? nonInlineTextWordStarts;

  // The end index of each word within the node's name. This is different
  // from wordEnds because it is not restricted to inline text boxes and can
  // be used for any type of element.
  attribute sequence<long>? nonInlineTextWordEnds;

  // The nodes, if any, which this node is specified to control via
  // <a href="http://www.w3.org/TR/wai-aria/#aria-controls">
  // <code>aria-controls</code></a>.
  attribute sequence<AutomationNode>? controls;

  // The nodes, if any, which form a description for this node.
  attribute sequence<AutomationNode>? describedBy;

  // The nodes, if any, which may optionally be navigated to after this
  // one. See
  // <a href="http://www.w3.org/TR/wai-aria/#aria-flowto">
  // <code>aria-flowto</code></a>.
  attribute sequence<AutomationNode>? flowTo;

  // The nodes, if any, which form a label for this element. Generally, the
  // text from these elements will also be exposed as the element's accessible
  // name, via the $(ref:automation.AutomationNode.name) attribute.
  attribute sequence<AutomationNode>? labelledBy;

  // The node referred to by <code>aria-activedescendant</code>, where
  // applicable
  attribute AutomationNode? activeDescendant;

  // Reverse relationship for active descendant.
  attribute sequence<AutomationNode>? activeDescendantFor;

  // The target of an in-page link.
  attribute AutomationNode? inPageLinkTarget;

  // A node that provides more details about the current node.
  attribute sequence<AutomationNode>? details;

  // The nodes, if any, that provide an error message for the current node.
  attribute sequence<AutomationNode>? errorMessages;

  // Reverse relationship for details.
  attribute sequence<AutomationNode>? detailsFor;

  // Reverse relationship for errorMessage.
  attribute sequence<AutomationNode>? errorMessageFor;

  // Reverse relationship for controls.
  attribute sequence<AutomationNode>? controlledBy;

  // Reverse relationship for describedBy.
  attribute sequence<AutomationNode>? descriptionFor;

  // Reverse relationship for flowTo.
  attribute sequence<AutomationNode>? flowFrom;

  // Reverse relationship for labelledBy.
  attribute sequence<AutomationNode>? labelFor;

  // The column header nodes for a table cell.
  attribute sequence<AutomationNode>? tableCellColumnHeaders;

  // The row header nodes for a table cell.
  attribute sequence<AutomationNode>? tableCellRowHeaders;

  // An array of standard actions available on this node.
  attribute sequence<ActionType>? standardActions;

  // An array of custom actions.
  attribute sequence<CustomAction>? customActions;

  // The action taken by calling <code>doDefault</code>.
  attribute DefaultActionVerb? defaultActionVerb;

  //
  // Link attributes.
  //

  // The URL that this link will navigate to.
  attribute DOMString? url;

  //
  // Document attributes.
  //

  // The URL of this document.
  attribute DOMString? docUrl;

  // The title of this document.
  attribute DOMString? docTitle;

  // Whether this document has finished loading.
  attribute boolean? docLoaded;

  // The proportion (out of 1.0) that this doc has completed loading.
  attribute double? docLoadingProgress;

  //
  // Scrollable container attributes.
  //

  attribute long? scrollX;
  attribute long? scrollXMin;
  attribute long? scrollXMax;
  attribute long? scrollY;
  attribute long? scrollYMin;
  attribute long? scrollYMax;

  // Indicates whether this node is scrollable.
  attribute boolean? scrollable;

  //
  // Editable text field attributes.
  //

  // The character index of the start of the selection within this editable
  // text element; -1 if no selection.
  attribute long? textSelStart;

  // The character index of the end of the selection within this editable
  // text element; -1 if no selection.
  attribute long? textSelEnd;

  // An array of Marker objects for this node.
  attribute sequence<Marker>? markers;

  //
  // Tree selection attributes (available on root nodes only)
  //

  // If a selection is present, whether the anchor of the selection comes
  // after its focus in the accessibility tree.
  attribute boolean? isSelectionBackward;
  // The anchor node of the tree selection, if any.
  attribute AutomationNode? anchorObject;
  // The anchor offset of the tree selection, if any.
  attribute long? anchorOffset;
  // The affinity of the tree selection anchor, if any.
  attribute DOMString? anchorAffinity;
  // The focus node of the tree selection, if any.
  attribute AutomationNode? focusObject;
  // The focus offset of the tree selection, if any.
  attribute long? focusOffset;
  // The affinity of the tree selection focus, if any.
  attribute DOMString? focusAffinity;

  // The selection start node of the tree selection, if any.
  attribute AutomationNode? selectionStartObject;
  // The selection start offset of the tree selection, if any.
  attribute long? selectionStartOffset;
  // The affinity of the tree selection start, if any.
  attribute DOMString? selectionStartAffinity;
  // The selection end node of the tree selection, if any.
  attribute AutomationNode? selectionEndObject;
  // The selection end offset of the tree selection, if any.
  attribute long? selectionEndOffset;
  // The affinity of the tree selection end, if any.
  attribute DOMString? selectionEndAffinity;

  // Indicates that the node is marked user-select:none
  attribute boolean? notUserSelectableStyle;

  //
  // Range attributes.
  //

  // The current value for this range.
  attribute double? valueForRange;

  // The minimum possible value for this range.
  attribute double? minValueForRange;

  // The maximum possible value for this range.
  attribute double? maxValueForRange;

  //
  // List attributes.
  //

  // The 1-based index of an item in a set.
  attribute long? posInSet;

  // The number of items in a set;
  attribute long? setSize;

  //
  // Table attributes.
  //

  // The number of rows in this table as specified in the DOM.
  attribute long? tableRowCount;

  // The number of rows in this table as specified by the page author.
  attribute long? ariaRowCount;

  // The number of columns in this table as specified in the DOM.
  attribute long? tableColumnCount;

  // The number of columns in this table as specified by the page author.
  attribute long? ariaColumnCount;

  //
  // Table cell attributes.
  //

  // The zero-based index of the column that this cell is in as specified in
  // the DOM.
  attribute long? tableCellColumnIndex;

  // The ARIA column index as specified by the page author.
  attribute long? tableCellAriaColumnIndex;

  // The number of columns that this cell spans (default is 1).
  attribute long? tableCellColumnSpan;

  // The zero-based index of the row that this cell is in as specified in the
  // DOM.
  attribute long? tableCellRowIndex;

  // The ARIA row index as specified by the page author.
  attribute long? tableCellAriaRowIndex;

  // The number of rows that this cell spans (default is 1).
  attribute long? tableCellRowSpan;

  // The corresponding column header for this cell.
  attribute AutomationNode? tableColumnHeader;

  // The corresponding row header for this cell.
  attribute AutomationNode? tableRowHeader;

  // The column index of this column node.
  attribute long? tableColumnIndex;

  // The row index of this row node.
  attribute long? tableRowIndex;

  //
  // Live region attributes.
  //

  // The type of region if this is the root of a live region.
  // Possible values are 'polite' and 'assertive'.
  attribute DOMString? liveStatus;

  // The value of aria-relevant for a live region.
  attribute DOMString? liveRelevant;

  // The value of aria-atomic for a live region.
  attribute boolean? liveAtomic;

  // The value of aria-busy for a live region or any other element.
  attribute boolean? busy;

  // The type of live region if this node is inside a live region.
  attribute DOMString? containerLiveStatus;

  // The value of aria-relevant if this node is inside a live region.
  attribute DOMString? containerLiveRelevant;

  // The value of aria-atomic if this node is inside a live region.
  attribute boolean? containerLiveAtomic;

  // The value of aria-busy if this node is inside a live region.
  attribute boolean? containerLiveBusy;

  //
  // Miscellaneous attributes.
  //

  // Whether or not this node is a button.
  attribute boolean isButton;

  // Whether or not this node is a checkbox.
  attribute boolean isCheckBox;

  // Whether or not this node is a combobox.
  attribute boolean isComboBox;

  // Whether or not this node is an image.
  attribute boolean isImage;

  // Whether the node contains hidden nodes.
  attribute boolean hasHiddenOffscreenNodes;

  // Aria auto complete.
  attribute DOMString? autoComplete;

  // The name of the programmatic backing object.
  attribute DOMString? className;

  // Marks this subtree as modal.
  attribute boolean? modal;

  // A map containing all HTML attributes and their values
  // <jsexterns>@type {Object<string>}</jsexterns>
  attribute object? htmlAttributes;

  // The input type of a text field, such as "text" or "email".
  attribute DOMString? inputType;

  // The key that activates this widget.
  attribute DOMString? accessKey;

  // The value of the aria-invalid attribute, indicating the error type.
  attribute DOMString? ariaInvalidValue;

  // The CSS display attribute for this node, if applicable.
  attribute DOMString? display;

  // A data url with the contents of this object's image or thumbnail.
  attribute DOMString? imageDataUrl;

  // The author-provided language code for this subtree.
  attribute DOMString? language;

  // The detected language code for this subtree.
  attribute DOMString? detectedLanguage;

  // Indicates the availability and type of an interactive popup element.
  attribute HasPopup? hasPopup;

  // Input restriction, if any, such as readonly or disabled:
  // undefined - enabled control or other object that is not disabled
  // Restriction.DISABLED - disallows input in itself + any descendants
  // Restriction.READONLY - allow focus/selection but not input
  attribute DOMString? restriction;

  // Tri-state describing checkbox or radio button:
  // 'false' | 'true' | 'mixed'
  attribute DOMString? checked;

  // The inner html of this element. Only populated for math content.
  attribute DOMString? innerHtml;

  // The RGBA foreground color of this subtree, as an integer.
  attribute long? color;

  // The RGBA background color of this subtree, as an integer.
  attribute long? backgroundColor;

  // The RGBA color of an input element whose value is a color.
  attribute long? colorValue;

  // Indicates node text is subscript.
  attribute boolean subscript;

  // Indicates node text is superscript.
  attribute boolean superscript;

  // Indicates node text is bold.
  attribute boolean bold;

  // Indicates node text is italic.
  attribute boolean italic;

  // Indicates node text is underline.
  attribute boolean underline;

  // Indicates node text is line through.
  attribute boolean lineThrough;

  // Indicates whether this node is selected, unselected, or neither.
  attribute boolean? selected;

  // Indicates the font size of this node.
  attribute long? fontSize;

  // Indicates the font family.
  attribute DOMString fontFamily;

  // Indicates whether the object functions as a text field which exposes its
  // descendants. Use cases include the root of a content-editable region, an
  // ARIA textbox which isn't currently editable and which has interactive
  // descendants, and a <body> element that has "design-mode" set to "on".
  attribute boolean nonAtomicTextFieldRoot;

  // Indicates aria-current state.
  attribute AriaCurrentState? ariaCurrentState;

  // Indicates invalid-state.
  attribute InvalidState? invalidState;

  // The application id for a tree rooted at this node.
  attribute DOMString? appId;

  //
  // Walking the tree.
  //

  attribute sequence<AutomationNode> children;
  attribute AutomationNode? parent;
  attribute AutomationNode? firstChild;
  attribute AutomationNode? lastChild;
  attribute AutomationNode? previousSibling;
  attribute AutomationNode? nextSibling;
  attribute AutomationNode? previousOnLine;
  attribute AutomationNode? nextOnLine;
  attribute AutomationNode? previousFocus;
  attribute AutomationNode? nextFocus;
  attribute AutomationNode? previousWindowFocus;
  attribute AutomationNode? nextWindowFocus;

  // The index of this node in its parent node's list of children. If this is
  // the root node, this will be undefined.
  attribute long? indexInParent;

  // The sort direction of this node.
  attribute SortDirectionType sortDirection;

  // Explicitly set to true when this node is clickable.
  attribute boolean clickable;

  //
  // Actions.
  //

  // Does the default action based on this node's role. This is generally
  // the same action that would result from clicking the node such as
  // expanding a treeitem, toggling a checkbox, selecting a radiobutton,
  // or activating a button.
  void doDefault();

  // Places focus on this node.
  void focus();

  // Request a data url for the contents of an image, optionally
  // resized.  Pass zero for maxWidth and/or maxHeight for the
  // original size.
  void getImageData(long maxWidth, long maxHeight);

  // Does a hit test of the given global screen coordinates, and fires
  // eventToFire on the resulting object.
  void hitTest(
      long x,
      long y,
      EventType eventToFire);

  // Does a $(ref:automation.AutomationNode.hitTest), and receives a callback
  // with the resulting hit node.
  void hitTestWithReply(
      long x,
      long y,
      PerformActionCallbackWithNode callback);

  // Scrolls this node to make it visible.
  void makeVisible();

  // Performs custom action.
  void performCustomAction(long customActionId);

  // Convenience method to perform a standard action supported by this node.
  // For actions requiring additional arguments, call the specific binding
  // e.g. <code>setSelection</code>.
  void performStandardAction(ActionType actionType);

  // Replaces the selected text within a text field.
  void replaceSelectedText(DOMString value);

  // Sets accessibility focus. Accessibility focus is the node on which an
  // extension tracks a user's focus. This may be conveyed through a focus
  // ring or or speech output by the extension. Automation will dispatch more
  // events to the accessibility focus such as location changes.
  void setAccessibilityFocus();

  // Sets selection within a text field.
  void setSelection(long startIndex, long endIndex);

  // Clears focus and sets this node as the starting point for the next
  // time the user presses Tab or Shift+Tab.
  void setSequentialFocusNavigationStartingPoint();

  // Sets the value of a text field.
  void setValue(DOMString value);

  // Show the context menu for this element, as if the user right-clicked.
  void showContextMenu();

  // Resume playing any media within this tree.
  void resumeMedia();

  // Start ducking any media within this tree.
  void startDuckingMedia();

  // Stop ducking any media within this tree.
  void stopDuckingMedia();

  // Suspend any media playing within this tree.
  void suspendMedia();

  // Simulates long click on node.
  void longClick();

  // Scrolls this scrollable container backward.
  void scrollBackward(optional PerformActionCallback callback);

  // Scrolls this scrollable container forward.
  void scrollForward(optional PerformActionCallback callback);

  // Scrolls this scrollable container up.
  void scrollUp(optional PerformActionCallback callback);

  // Scrolls this scrollable container down.
  void scrollDown(optional PerformActionCallback callback);

  // Scrolls this scrollable container left.
  void scrollLeft(optional PerformActionCallback callback);

  // Scrolls this scrollable container right.
  void scrollRight(optional PerformActionCallback callback);

  // Scrolls this scrollable container to the given point.
  void scrollToPoint(long x, long y);

  // Sets this scrollable container's scroll offset.
  void setScrollOffset(long x, long y);

  // Adds a listener for the given event type and event phase.
  void addEventListener(
      EventType eventType, AutomationListener listener, boolean capture);

  // Removes a listener for the given event type and event phase.
  void removeEventListener(
      EventType eventType, AutomationListener listener, boolean capture);

  // Finds the first AutomationNode in this node's subtree which matches the
  // given search parameters.
  AutomationNode find(FindParams params);

  // Finds all the AutomationNodes in this node's subtree which matches the
  // given search parameters.
  sequence<AutomationNode> findAll(FindParams params);

  // Returns whether this node matches the given $(ref:automation.FindParams).
  boolean matches(FindParams params);

  AutomationNode getNextTextMatch(
      DOMString searchStr, boolean backward);

  // Creates a position object backed by Chrome's accessibility position support.
  AutomationPosition createPosition(PositionType type, long offset, optional boolean isUpstream);
};

// Called when the <code>AutomationNode</code> for the page is available.
[Namespace=(chrome, automation)]
callback RootCallback = void(AutomationNode rootNode);

// Called with the <code>AutomationNode</code> that currently has focus.
[Namespace=(chrome, automation)]
callback FocusCallback = void(AutomationNode focusedNode);

// Called with the <code>AutomationNode</code> that currently has
// accessibility focus.
[Namespace=(chrome, automation)]
callback AccessibilityFocusCallback = void(AutomationNode focusedNode);

[Namespace=(chrome, automation)]
interface Functions {
  // Get the automation tree for the tab with the given tabId, or the current
  // tab if no tabID is given, enabling automation if necessary. Returns a
  // tree with a placeholder root node; listen for the "loadComplete" event to
  // get a notification that the tree has fully loaded (the previous root node
  // reference will stop working at or before this point).
  [nocompile] static void getTree(optional long tabId,
                                  optional RootCallback callback);

  // Get the automation tree for the whole desktop which consists of all on
  // screen views. Note this API is currently only supported on Chrome OS.
  [nocompile] static void getDesktop(RootCallback callback);

  // Get the automation node that currently has focus, globally. Will return
  // null if none of the nodes in any loaded trees have focus.
  [nocompile] static void getFocus(FocusCallback callback);

  // Get the automation node that currently has accessibility focus, globally.
  // Will return null if none of the nodes in any loaded trees have
  // accessibility focus.
  [nocompile] static void getAccessibilityFocus(
      AccessibilityFocusCallback callback);

  // Add a tree change observer. Tree change observers are static/global, they
  // listen to changes across all trees. Pass a filter to determine what
  // specific tree changes to listen to, and note that listnening to all
  // tree changes can be expensive.
  [nocompile] static void addTreeChangeObserver(
      TreeChangeObserverFilter filter, TreeChangeObserver observer);

  // Remove a tree change observer.
  [nocompile] static void removeTreeChangeObserver(
      TreeChangeObserver observer);

  // Sets the selection in a tree. This creates a selection in a single
  // tree (anchorObject and focusObject must have the same root).
  // Everything in the tree between the two node/offset pairs gets included
  // in the selection. The anchor is where the user started the selection,
  // while the focus is the point at which the selection gets extended
  // e.g. when dragging with a mouse or using the keyboard. For nodes with
  // the role staticText, the offset gives the character offset within
  // the value where the selection starts or ends, respectively.
  [nocompile] static void setDocumentSelection(
      SetDocumentSelectionParams params);
};
