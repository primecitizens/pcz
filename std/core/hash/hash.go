// SPDX-License-Identifier: Apache-2.0
// Copyright 2023 The Prime Citizens

package hash

import (
	"unsafe"

	stdstring "github.com/primecitizens/pcz/std/builtin/string"
	stdtype "github.com/primecitizens/pcz/std/builtin/type"
	"github.com/primecitizens/pcz/std/core/abi"
	"github.com/primecitizens/pcz/std/core/arch"
	"github.com/primecitizens/pcz/std/core/assert"
	"github.com/primecitizens/pcz/std/core/thread"
)

var (
	// used in hash{32,64}.go to seed the hash function
	hashkey [4]uintptr
)

const (
	c0 = uintptr((8-arch.PtrSize)/4*2860486313 + (arch.PtrSize-4)/4*33054211828000289)
	c1 = uintptr((8-arch.PtrSize)/4*3267000013 + (arch.PtrSize-4)/4*23344194077549503)
)

func StringHash(p unsafe.Pointer, h uintptr) uintptr {
	str := (*stdstring.Header)(p)
	return MemHash(str.Str, h, uintptr(str.Len))
}

func Float32Hash(p unsafe.Pointer, h uintptr) uintptr {
	f := *(*float32)(p)
	switch {
	case f == 0:
		return c1 * (c0 ^ h) // +0, -0
	case f != f:
		return c1 * (c0 ^ h ^ uintptr(thread.G().G().Rand32())) // any kind of NaN
	default:
		return MemHash(p, h, 4)
	}
}

func Float64Hash(p unsafe.Pointer, h uintptr) uintptr {
	f := *(*float64)(p)
	switch {
	case f == 0:
		return c1 * (c0 ^ h) // +0, -0
	case f != f:
		return c1 * (c0 ^ h ^ uintptr(thread.G().G().Rand32())) // any kind of NaN
	default:
		return MemHash(p, h, 8)
	}
}

func Complex64Hash(p unsafe.Pointer, h uintptr) uintptr {
	x := (*[2]float32)(p)
	return Float32Hash(unsafe.Pointer(&x[1]), Float32Hash(unsafe.Pointer(&x[0]), h))
}

func Complex128Hash(p unsafe.Pointer, h uintptr) uintptr {
	x := (*[2]float64)(p)
	return Float64Hash(unsafe.Pointer(&x[1]), Float64Hash(unsafe.Pointer(&x[0]), h))
}

func InterfaceHash(p unsafe.Pointer, h uintptr) uintptr {
	a := (*stdtype.Iface)(p)
	tab := a.Itab
	if tab == nil {
		return h
	}
	t := tab.Type
	if t.Equal == nil {
		// Check hashability here. We could do this check inside
		// typehash, but we want to report the topmost type in
		// the error text (e.g. in a struct with a field of slice type
		// we want to report the struct, not the slice).
		assert.Panic("hash", "of", "unhashable", "type ", t.String())
		return h
	}

	if t.IsDirectIface() {
		return c1 * TypeHash(t, unsafe.Pointer(&a.Data), h^c0)
	} else {
		return c1 * TypeHash(t, a.Data, h^c0)
	}
}

func NilInterfaceHash(p unsafe.Pointer, h uintptr) uintptr {
	a := (*stdtype.Eface)(p)
	t := a.Type
	if t == nil {
		return h
	}
	if t.Equal == nil {
		// See comment in interhash above.
		assert.Panic("hash", "of", "unhashable", "type ", t.String())
		return h
	}

	if t.IsDirectIface() {
		return c1 * TypeHash(t, unsafe.Pointer(&a.Data), h^c0)
	} else {
		return c1 * TypeHash(t, a.Data, h^c0)
	}
}

// TypeHash computes the hash of the object of type t at address p.
// h is the seed.
// This function is seldom used. Most maps use for hashing either
// fixed functions (e.g. f32hash) or compiler-generated functions
// (e.g. for a type like struct { x, y string }). This implementation
// is slower but more general and is used for hashing interface types
// (called from interhash or nilinterhash, above) or for hashing in
// maps generated by reflect.MapOf (reflect_typehash, below).
// Note: this function must match the compiler generated
// functions exactly. See issue 37716.
func TypeHash(t *abi.Type, p unsafe.Pointer, h uintptr) uintptr {
	if t.TFlag&abi.TFlagRegularMemory != 0 {
		// Handle ptr sizes specially, see issue 37086.
		switch t.Size_ {
		case 4:
			return MemHash32(p, h)
		case 8:
			return MemHash64(p, h)
		default:
			return MemHash(p, h, t.Size_)
		}
	}

	switch t.Kind() {
	case abi.KindFloat32:
		return Float32Hash(p, h)
	case abi.KindFloat64:
		return Float64Hash(p, h)
	case abi.KindComplex64:
		return Complex64Hash(p, h)
	case abi.KindComplex128:
		return Complex128Hash(p, h)
	case abi.KindString:
		return StringHash(p, h)
	case abi.KindInterface:
		if len(t.InterfaceType().Methods) == 0 {
			return NilInterfaceHash(p, h)
		}
		return InterfaceHash(p, h)
	case abi.KindArray:
		for a, i := t.ArrayType(), uintptr(0); i < a.Len; i++ {
			h = TypeHash(a.Elem, unsafe.Add(p, i*a.Elem.Size_), h)
		}
		return h
	case abi.KindStruct:
		s := t.StructType()
		for _, f := range s.Fields {
			if f.Name.IsBlank() {
				continue
			}
			h = TypeHash(f.Typ, unsafe.Add(p, f.Offset), h)
		}
		return h
	default:
		// Should never happen, as typehash should only be called
		// with comparable types.
		assert.Panic("hash", "of", "unhashable", "type ", t.String())
		return h
	}
}
